## Java Swing GUI와 멀티스레딩을 활용한
## 재밌는 타자게임!


### 프로그램 개요
이 게임은 “재미있는 타자 연습”의 목적을 가지고 개발되었다. 기존의 지루한 타자 연습 게임, 단순히 화면에 나오는 단어와 문장만을 따라 입력하는 게임을 타파하고자 하는 것이 목적이다.

 초기 화면에서 ‘게임 시작’ 버튼을 누르면 게임이 시작된다. 게임은 한글 단어로 구성되어 있다. 사용자는 게임을 시작하면 화면에 나타나는 네 마리의 새와 50% 확률로 떨어지는 폭탄을 볼 수 있다. 각각의 새와 폭탄에는 어떤 한글 단어가 적혀 있고, 이 단어를 하단의 사용자 입력창에 정확히 입력하면 된다. 또, 화면 우측에는 현재 라운드와 점수, 남은 기회를 표시하는 하트 3개가 있다. 사용자가 입력한 단어에 해당하는 단어가 적혀 있는 새는, 총에 맞은 듯 한 폭발하는 이미지로 변하며 화면에 표시된다. 이 경우 사용자는 10점을 획득하게 된다. 점수는 우측 패널에서 확인할 수 있다. 또, 사용자가 입력한 단어가 폭탄에 적혀있는 단어였다면, 폭탄은 얼음이 깨지는 듯한 모양으로 폭발하며 모든 새의 움직임이 3초간 정지된다. 폭탄은 점수를 주지는 않지만, 새의 움직임을 멈춰 사용자가 좀 더 편하게 단어를 인식하게 해 준다. 모든 새가 사냥되면 라운드가 높아지고, 높아질수록 새의 이동속도가 빨라져 단어를 알아보기 힘들기 때문이다. 이렇듯 중요한 폭탄은 좌우로만 비행하는 새와는 달리 하늘에서 땅으로 떨어진다. 폭탄이 땅에 닿기 전에 단어를 입력해 터트리지 못하면, 그 라운드에서 폭탄을 다시 만날 순 없다. 만약 급한 마음에 오답을 입력하면 하트의 개수가 하나씩 줄어들고, 모든 하트가 소모되면 게임은 패배로 끝나게 된다.
 
 이 게임의 재미를 주는 가장 큰 포인트는 화면 상단에 출력되는 ‘잡으면 안되는 새’이다. 매 라운드마다 잡으면 안되는 새가 랜덤하게 정해지고, 화면 상단에 나타난다. 잡으면 안되는 새에 해당하는 단어를 입력하면 오히려 점수가 감소하고 하트가 줄어든다. 오답과 같은 처리를 하게 되는 것이다. 네 마리의 새가 화면에서 퍼덕이고, 폭탄이 떨어지는 상황에 정신이 없지만, 정확히 새를 알아보고 입력해야 하는 부분이 재미의 포인트가 될 것으로 기대한다.

모든 하트를 소모하고 게임이 종료되면, 사용자의 이름을 입력받는다. 사용자가 이름을 입력하면 그 이름과 점수, 라운드가 저장되어 랭킹 시스템에 활용된다. 최고 고득점자 3명은 각각 메달을 받고, 게임 실행 중에 화면 우측에 그 이름과 점수, 메달이 표시된다. 이를 통해 사용자는 경쟁하는 재미도 느낄 수 있다. 게임이 종료되면 자동으로 초기 메뉴 화면으로 되돌아간다.

초기 메뉴 화면의 ‘단어 추가’ 버튼을 누르면 단어 입력 메뉴로 이동한다. 화면 중앙의 텍스트 입력 창에 단어를 입력하면, 그 단어는 새와 폭탄 이름에 적혀 나오는 단어들 중 하나로 추가된다. 단어의 목록은 게임 폴더/source/korean.txt 파일에서 확인, 추가할 수 있다. 

### 초기화면


![캡처1](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/600e0d15-4c89-4b4f-bc4f-869aa24e320f)
게임의 초기 실행 모습
'게임 시작' 버튼을 눌러 시작할 수 있고, '단어 추가' 버튼을 눌러 단어 Edit 모드로 이동할 수 있다.

### 실행 화면


![캡처2](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/6c142f52-94bd-4f25-a624-c1ed9e9cc438)
상단의 사냥하면 안되는 새는, 사용자 입력창에 단어를 입력하면 오히려 감점당하고 우측 하트가 감소한다.
떨어지고 있는 보너스 폭탄의 문구를 입력하면, 잠깐동안 모든 새의 움직임을 멈출 수 있다.
각 새는 모두 움직임의 방향과 그 속도가 다르다.

![캡처3](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/f43b954b-0455-4714-b5c0-de7ce47a0e21)
정답을 입력하면 새가 사라지며 점수가 올라간다.
또, 우측 라운드가 증가할 수록 새의 속도가 점점 빨라진다! 보너스 폭탄을 잘 활용해야 한다.

![캡처4](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/aa255640-73ac-4296-86cb-4e8e4eb1c521)
잘못된 답을 입력하거나, 상단의 사냥하면 안되는 새의 단어를 입력한 경우이다.
화면에 X 표시가 출력되며 우측 하트가 감소한다.

![캡처5](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/1ff0213b-ad35-4468-a55d-d1df7d1cc404)
모든 하트를 소모하면 You Lose 가 출력되며 게임이 종료된다.

![캡처10](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/de0f7b50-c133-4733-adde-648551a33a2a)
점수에 따른 랭킹을 입력할 수 있다.
랭킹은 개인 PC의 File에 저장된다. 나오는 단어의 데이터베이스도 개인 PC에 저장된 파일에서 불러온다.
함께 로컬 PC에 데이터베이스를 사용하는 방식이다.
실제 데이터베이스 구조는 아니고, 단순 txt 파일이다.

![캡처6](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/8d5269e5-09b5-4b4d-a5ba-2f17d08deb85)
단어 추가 메뉴의 화면이다.
단어를 입력하면 데이터베이스로 사용하는 txt파일에 자동으로 추가된다.

![캡처7](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/4670b15a-b0cf-4d30-a744-2803cd55a98f)
데이터베이스로 사용하는 단어장 txt 파일이다.
단어추가 메뉴의 화면에서 객체지향언어2를 입력해서 입력된 모습을 볼 수 있다.


## 프로그램 구조

![image](https://github.com/Jun-Young-Seo/word_game_hunting_birds/assets/128452954/5ef59063-e989-4bd1-afff-72ee3facf278)

이 프로그램의 클래스 계층 구조(클래스 다이어그램)이다. 
GameApp에는 이 프로그램의 진입점인 Main 함수가 있고, 이 함수엔 GameFrame의 생성자만 존재한다. GameFrame에는 ‘게임 시작’, ‘단어 추가’, ‘나가기’ 3개의 버튼이 있고, 이는 각각 GamePanel, AddWordPanel, 게임 종료를 실행하게 된다.
 
 먼저, GamePanel은 좌측의 GameGround와 우측의 ScorePanel로 나누어지는데, ScorePanel에는 현재 라운드, 점수, 남은 하트와 랭킹 1, 2, 3등의 기록이 표시된다.
 GameGround는 타자 연습 게임이 실행되는 부분으로, 단어를 가진 새와 폭탄, 잡으면 안되는 새, 사용자 입력 창이 위치한다. 이 GameGround에 날아다니는 새들은 추상클래스 Bird를 상속받아 만들어진다. 각 새의 코드 구조가 유사하기 때문에 추상클래스를 상속받도록 설계되었다. Bomb클래스는 화면에 떨어지는 폭탄을 구현하는 클래스다. 폭탄과 새의 몸에 적히게 되는 단어들은 텍스트 파일로부터 단어 목록을 받아와 랜덤하게 단어를 선정하는 TextSource에서 선택한다.
 
 Bird를 상속받은 각 새 클래스들은 날아다니는 모습을 구현한 스레드를 실행시키고, Bomb는 폭탄이 떨어지는 모습을 구현한 스레드를 실행시킨다. GameGround는 게임의 전체적인 메인 실행 로직을 담당하는 메인 스레드와 잡으면 안되는 새를 표시하는 스레드 2개를 실행시킨다. 잡으면 안되는 새를 사냥이 끝났을 경우에 변경하기 위해 이 두 스레드는 동기화되어 있다. 동기화하지 않을 경우 Deda-Lock 발생.



### 프로젝트를 진행하며 느낀 점...

프로젝트를 진행하면서 크게 두 가지의 어려움을 겪었다. 첫 번째는 새의 날개 움직임을 그럴싸하게 구현하는 것이었고, 두 번째는 잡으면 안되는 새를 만드는 것이었다.
물론 이 두가지의 기능은 필수적으로 구현해야하는 것은 아니었다. 하지만, 프로젝트를 진행하며 스스로 고집이 생겼다. 포기하지 않고 끝까지 완성해 냈다.

 먼저, 새의 움직임을 구현하기 위한 아이디어는 교수님과 함께 강의 시간에 풀이했던 간단한 스윙 프로그램에서 아이디어를 얻었다. @로 표시되는 사용자가 M으로 표시되는 괴물을 피해 달아나는 아주 간단한 콘솔 게임이었다. 
  빠르게 움직이면 생각보다 자연스러운 움직임이 나오는 것을 깨닫고, 새가 날개를 퍼덕이는 듯한 모습을 보이기 위해 위아래를 향한 날개의 모습과 머리 방향이 좌우인 4개의 이미지를 구했다. 레이블의 이미지를 바꾸면서 움직이고, 스레드로 이 행동을 빠르게 하자 꽤 자연스러운 새의 움직임을 구현할 수 있었다.
  
 두 번째는, 잡으면 안되는 새였다. 문득 떠오른 아이디어였고 정말 어려웠지만 재밌을 것 같아서 끝까지 욕심부려 완성했다. 어느정도 완성했을 때, 여러 가지 문제가 생겼었다. 처음 구현했을 때는 스레드 동기화를 이해하지 못하고 그저 따로 작동하는 스레드로 구현했었다. 이렇게 하자, 사냥이 끝나지도 않았는데 사냥하면 안되는 새가 바뀌거나, 사냥하면 안되는 새를 잡아도 점수가 오르거나, 사냥하면 안되는 새의 스레드가 또 작동해 새 레이블이 겹치는 등 정말 많은 문제가 발생했다. 또, 인터럽트를 발생시켜 이미지를 바꾸는 방식으로 구현하니 sleep 시간동안 인터럽트 예외가 발생하지 않는 경우도 생겼다. 이 문제를 해결하기 위해 Flag를 사용하기도 했는데, 사냥이 완료된 시점에 기존의 새들이 채 제거되기도 전에 새로운 새가 추가되어 화면에 너무 많은 새가 있는 문제가 생기기도 했다. 외에도 예측할 수 없는 순간에 데드락이 걸리거나, 프로그램이 뻗어버리기도 했다. 책에서만, 코드로만 봐 왔던 Deda-Lock을 직접 마주했다.
 또, 잡으면 안되는 새만 남아 있을 때는 다음 라운드로 진행해야 한다. 이것의 구현 역시 쉽지 않았다. 아이디어를 바꿔, 잡아야 하는 모든 새를 관리하는 벡터를 추가했다. 벡터의 모든 새가 소모되면 라운드를 진행하는 방식으로 바꾸었다.
 새롭게 라운드가 시작되면, 각 새의 클래스들은 새로운 Bird 객체를 생성하고, 벡터에 추가한다.
 
 스레드 동기화 강의를 듣고, 책을 찾아보며 스스로 공부하고 고민하기도 하면서 문제를 해결했다. 사냥하면 안되는 새는 한번 실행 후 wait하고, 사냥이 완료되면 게임을 진행하는 메인 스레드가 사냥하면 안되는 새를 설정하는 스레드를 깨운다. notify되는 순간 이 스레드는 기존의 사냥하면 안되는 새를 다른 새로 바꾸게 된다. 또, 기존의 새들이 제거되기 전에 새로운 새들이 추가되던 문제는 join을 통해 해결했다. 사냥하면 안되는 새나, 메인 게임 스레드와는 다르게 각 새들의 스레드는 정답을 맞출 때 마다 인터럽트를 통해 return을 실행하고 종료된다. join을 통해 각 새들의 스레드가 끝날 때 까지 기다려주도록 구현해서 문제를 해결했다. 뮤텍스 라이브러리를 활용해도 됐지만, 당시 지식의 내용을 뛰어 넘는 내용이기도 했고, 스스로 해결해보고 싶었다.

 두 가지 문제 외에도, Bomb의 구현이나, 세련된 디자인, 랭킹 시스템 등 여러 문제를 겪었다. 여러 문제를 겪으면서 세부적으로 알게 된 것이 정말 많았다. 예를 들어, 단어를 저장하는 함수에서 FileWriter의 두 번째 매개변수로 true를 주는 것을 몰라서 단어 소스파일을 통째로 날려버리기도 했다. 소스파일을 어디서 구했었는지 기억이 나지않아 정말 난처했었다. 결국 다시 찾아내고, 두 번째 매개변수가 어떤 기능을 하는지 알게 되었다. 역시 경험하며 배우는 것...


보안 IOT 시스템을 제작하는 프로젝트를 할 때도 느꼈지만, 좋은 프로그래머는 “단순히 코드를 잘 짠다.”, “알고리즘을 잘 짠다.” 와는 좀 다른 것 같다. 하나의 온전한 프로그램을 만들기 위해선 알아야 할 것이 정말 너무너무 많다. 그 모든 것들을 깊이 있게, 정확히 이해해서 활용하는 능력을 갖춘 사람이 좋은 프로그래머가 되는 것 같다. IOT 프로젝트에선 통신 프로토콜과 하드웨어와 센서에 대한 이해가 필요했듯, GUI 게임 프로젝트 완성을 위해선 스레드와 그래픽, 객체지향프로그래밍에 대해 모두 이해하고 있어야 했다.

 그래도 꽤 그럴싸한 게임을 완성해서 뿌듯하다. 덕분에 코딩하는 것에 대한 자신감이 한 층 높아졌다.

책에 모든 지식을 적어둘 수도 없고, 내 이해와 암기가 완벽할 수 없다는 것도 알았다. 직접 무언가를 만들어 보면서, 부족한 부분을 깨닫고, 공부하고, 궁금하고 답답한 부분을 찾아가며 공부하는 것이 진짜 프로그래밍 공부라는 것을 깨닫게 됐다.

더 자세한 내용과 코드, 주석은 프로젝트 결과 보고서 PDF 파일을 참고해주세요!
